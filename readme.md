# Git 

## Что такое Git

**Git** (произносится «гит»[7]) — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано.

## Подготовка репозитория

1. Обычно вы получаете репозиторий Git одним из двух способов:

2. Вы можете взять локальный каталог, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git, либо

Вы можете клонировать существующий репозиторий Git из любого места.

В обоих случаях вы получите готовый к работе Git репозиторий на вашем компьютере.

**Создание репозитория в существующем каталоге**

Если у вас уже есть проект в каталоге, который не находится под версионным контролем Git, то для начала нужно перейти в него. Если вы не делали этого раньше, то для разных операционных систем это выглядит по-разному:

_для Windows_:

$ cd C:/Users/user/my_project

а затем выполните команду:

$ git init

## Создание "сохранений"

тут и add, commit и status, !!!
тут и add, commit и status

Хочу ли я создать конфликт?!

# Перемещение между сохранениями

* **git checkout** — переключение между ветками, извлечение файлов

* Команда **_git checkout_** позволяет переключаться между последними коммитами (если упрощенно) веток:
**checkout some-other-branch** 

* Создаёт ветку, в которую и произойдет переключение:
**_git checkout -b some-other-new-branch_** - 

* **_-f:_** Если в текущей ветке были какие-то изменения по сравнению с последним коммитом в ветке(HEAD), то команда откажется производить переключение, дабы не потерять произведенную работу. Проигнорировать этот факт позволяет ключ
**_git checkout -f some-other-branch_**

* В случае, когда изменения надо все же сохранить, следует использовать ключ -m. Тогда команда перед переключением попробует залить изменения в текущую ветку и, после разрешения возможных конфликтов переключиться в новую:
**_git checkout -m some-other-branch_**

* Вернуть файл (или просто вытащить из прошлого коммита) позволяет команда вида:
**_git checkout somefile_**

* Возвращает somefile к состоянию последнего коммита:
**_git checkout somefile_**

* Возвращает somefile к состоянию на два коммита назад по ветке:
**_git checkout HEAD~2 somefile_**

# git log — разнообразная информация о коммитах в целом

* Иногда требуется получить информацию об истории коммитов; коммитах, изменивших отдельный файл; коммитах за определенный отрезок времени и так далее. Для этих целей используется команда **_git log_**.

* Простейший пример использования, в котором приводится короткая справка по всем коммитам, коснувшимся активной в настоящий момент ветки (о ветках и ветвлении подробно узнать можно ниже, в разделе «Ветвления и слияния»):
**_git log_**

* **_-p (или -u)_** Получает подробную информацию о каждом в виде патчей по файлам из коммитов можно, добавив ключ:
**_git log -p_** 

* **_--stat_**: Статистика изменения файлов, вроде числа измененных файлов, внесенных в них строк, удаленных файлов вызывается ключом  **_git log --stat_**

* **_--summary_** За информацию по созданиям, переименованиям и правам доступа файлов отвечает ключ: **_git log --summary_**

* Чтобы просмотреть историю отдельного файла, достаточно указать в виде параметра его имя (кстати, в моей старой версии git этот способ не срабатывает, обязательно добавлять " — " перед «README»): **_git log README_** 
* или, если версия git не совсем свежая: **_git log — README_**

* Далее приводится только более современный вариант синтаксиса. Возможно указывать время, начиная в определенного момента («weeks», «days», «hours», «s» и так далее):
1. git log --since=«1 day 2 hours» README
2. git log --since=«2 hours» README

* изменения, касающиеся отдельной папки:
**_git log --since=«2 hours» dir/_**

# Можно отталкиваться от тегов.
## Все коммиты, начиная с тега v1:
**_git log v1_**...

1. Все коммиты, включающие изменения файла README, начиная с тега v1:

* git log v1... README

2. Все коммиты, включающие изменения файла README, начиная с тега v1 и заканчивая тегом v2:

* git log v1..v2 README
# Интересные возможности по формату вывода команды предоставляет ключ **_--pretty_**.
1. Выводит на каждый из коммитов по строчке, состоящей из хэша (здесь — уникального идентификатора каждого коммита, подробней — дальше):
 **_git log --pretty=oneline_**

2. Лаконичная информация о коммитах, приводятся только автор и комментарий:
 **_git log --pretty=short_**

3. Более полная информация о коммитах, с именем автора, комментарием, датой создания и внесения коммита:
**_git log --pretty=full/fuller_**

4. В принципе, формат вывода можно определить самостоятельно:
**_git log --pretty=format:'FORMAT'_**

5. Определение формата можно поискать в разделе по git log из Git Community Book или справке. Красивый ASCII-граф коммитов выводится с использованием ключа **_--graph._**

# Ветвление

Работа с ветками — очень легкая процедура в git, все необходимые механизмы сконцентрированы в одной команде.

* **_git branch_** — просто перечислит существующие ветки, отметив активную.

* **_git branch new-branch_** — создаст новую ветку new-branch.

 * **_git branch -d new-branch_** — удалит ветку, если та была залита (merged) с
разрешением возможных конфликтов в текущую.

* **_git branch -D new-branch_** — удалит ветку в любом случае.

* **_git branch -m new-name-branch_** — переименует ветку.

* **_git branch --contains v1.2_** — покажет те ветки, среди предков которых есть определенный коммит.
# Слияние веток (разрешение возможных конфликтов). **_git merge_**

Слияние веток, в отличие от обычной практики централизованных систем, в git
происходит практически каждый день. Естественно, что имеется удобный интерфейс к
популярной операции:
**_git merge new-feature_** — попробует объединить текующую ветку и ветку new-feature.

В случае возникновения конфликтов коммита не происходит, а по проблемным файлам
расставляются специальные метки а ля svn; сами же файлы отмечаются в индексе как
«не соединенные» (unmerged). До тех пор пока проблемы не будут решены, коммит совершить
будет нельзя.

Например, конфликт возник в файле TROUBLE, что можно увидеть в git status:

* **_git merge experiment_** — произошла неудачная попытка слияния.

* **_git status_** — смотрим на проблемные места.

* **_edit TROUBLE_** — разрешаем проблемы.

* **_git add._** — индексируем наши изменения, тем самым снимая метки.

 * **_git commit_** — совершаем коммит слияния.

 Вот и все, ничего сложного. Если в процессе разрешения вы передумали разрешать
конфликт, достаточно набрать:

* **_git reset --hard HEAD_** — это вернет обе ветки в исходные состояния.

Если же коммит слияния был совершен, используем команду:

* **_git reset --hard ORIG_HEAD_**

# Удаление веток

* **_git branch -d new-branch_** — удалит ветку, если та была залита (merged) с
разрешением возможных конфликтов в текущую.

* **_git branch -D new-branch_** — удалит ветку в любом случае.


For more information, please visit: https://studizba.com/files/show/doc/207459-2-git_komandnaya-stroka.html